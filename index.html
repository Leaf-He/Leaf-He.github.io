<!doctype html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" >
    <meta http-equiv="X-UA-Compatible" content="IE=11,IE=10,IE=9,IE=8" >
    <meta name="baidu-site-verification" content="dIcXMeY8Ya" />
    
    <title>Hexo</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0" >
    <meta name="keywords" content="Jelon, 前端, Web, 张德龙, 前端开发" >
    <meta name="description" content="Jelon个人前端小站" >

    
    <link rel="alternative" href="/atom.xml" title="Hexo" type="application/atom+xml" >
    
    
    <link rel="shortcut icon" href="/favicon.ico" >
    
    
<link rel="stylesheet" href="/css/style.css">

    <!--[if lt IE 9]>
    
<script src="/js/html5.js"></script>

    <![endif]-->
    
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?d5ebf515ab530cfbdda5f5c85093fb41";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>


<meta name="generator" content="Hexo 4.2.0"></head>

<body class="home">
    <!--[if lt IE 9]>
    <div class="browsehappy">
        当前网页 <strong>不支持</strong>
        你正在使用的浏览器. 为了正常的访问, 请 <a href="http://browsehappy.com/" target="_blank" rel="noopener">升级你的浏览器</a>.
    </div>
    <![endif]-->

    <!-- 博客头部 -->
    <header class="header">
    <section class="container header-main">
        <div class="logo">
            <a href="/">
                <div class="cover">
                    <span class="name">Hexo</span>
                    <span class="description"></span>
                </div>
            </a>
        </div>
        <div class="dropnav icon-paragraph-justify" id="JELON__btnDropNav"></div>
        <ul class="menu hidden" id="JELON__menu">
            
            <li rel="/index.html" class="item current">
                <a href="/" title="首页" class="icon-home">&nbsp;首页</a>
            </li>
            
            <li rel="/index.html" class="item ">
                <a href="/lab/" title="实验室" class="icon-lab">&nbsp;实验室</a>
            </li>
            
            <li rel="/index.html" class="item ">
                <a href="/about/" title="关于" class="icon-about">&nbsp;关于</a>
            </li>
            
            <li rel="/index.html" class="item ">
                <a href="/comment/" title="留言" class="icon-comment">&nbsp;留言</a>
            </li>
            
        </ul>
        <div class="profile clearfix">
            <div class="feeds fl">
                
                
                <p class="links">
                    
                        <a href="https://github.com/jangdelong" target="_blank">Github</a>
                        |
                    
                        <a href="https://pages.coding.me" target="_blank">Hosted by Coding Pages</a>
                        
                    
                </p>
                <p class="sns">
                    
                        <a href="http://weibo.com/jangdelong" class="sinaweibo" target="_blank"><b>■</b> 新浪微博</a>
                    
                        <a href="https://www.facebook.com/profile.php?id=100011855760219&amp;ref=bookmarks" class="qqweibo" target="_blank"><b>■</b> Facebook</a>
                    
                    <a href="javascript: void(0);" class="wechat">
                        <b>■</b>
                        公众号
                        <span class="popover">
                            <img src="/img/wechat_mp.jpg" width="120" height="120" alt="我的微信订阅号">
                            <i class="arrow"></i>
                        </span>
                    </a>
                </p>
                
            </div>
            <div class="avatar fr">
                <img src="/img/jelon.jpg" alt="avatar" title="Jelon" >
            </div>
        </div>
    </section>
</header>


    <!-- 博客正文 -->
    <div class="container body clearfix">
        <section class="content">
            <div class="content-main widget">
                <!-- 首页 -->

    
    <h3 class="widget-hd">
        <strong>
            
                最近动态
            
        </strong>
    </h3>
    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
            <a href="javascript: void(0);" class="cat">未分类</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="http://yoursite.com/2020/04/10/Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/">
    		Explain详解与索引最佳实践
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2020-04-10T06:05:11.688Z">2020-04-10</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>使用EXPLAIN关键字可以模拟优化器执行SQL语句，从而知道MySQL是 如何处理你的SQL语句的。分析你的查询语句或是结构的性能瓶颈<br>下面是使用 explain 的例子：<br>在 select 语句之前增加 explain 关键字，MySQL 会在查询上设置一个标记，执行查询时，会返回执行计划的信息，而不是执行这条SQL（如果 from 中包含子查询，仍会执行该子查询，将结果放入临时表中）<br>使用的表<br>DROP TABLE IF EXISTS <code>actor</code>;<br>CREATE TABLE <code>actor</code> (<br>  <code>id</code> int(11) NOT NULL,<br>  <code>name</code> varchar(45) DEFAULT NULL,<br>  <code>update_time</code> datetime DEFAULT NULL,<br>  PRIMARY KEY (<code>id</code>)<br>) ENGINE=InnoDB DEFAULT CHARSET=utf8;</p>
<p>INSERT INTO <code>actor</code> (<code>id</code>, <code>name</code>, <code>update_time</code>) VALUES (1,’a’,’2017-12-22 15:27:18’), (2,’b’,’2017-12-22 15:27:18’), (3,’c’,’2017-12-22 15:27:18’);</p>
<p>DROP TABLE IF EXISTS <code>film</code>;<br>CREATE TABLE <code>film</code> (<br>  <code>id</code> int(11) NOT NULL AUTO_INCREMENT,<br>  <code>name</code> varchar(10) DEFAULT NULL,<br>  PRIMARY KEY (<code>id</code>),<br>  KEY <code>idx_name</code> (<code>name</code>)<br>) ENGINE=InnoDB DEFAULT CHARSET=utf8;</p>
<p>INSERT INTO <code>film</code> (<code>id</code>, <code>name</code>) VALUES (3,’film0’),(1,’film1’),(2,’film2’);</p>
<p>DROP TABLE IF EXISTS <code>film_actor</code>;<br>CREATE TABLE <code>film_actor</code> (<br>  <code>id</code> int(11) NOT NULL,<br>  <code>film_id</code> int(11) NOT NULL,<br>  <code>actor_id</code> int(11) NOT NULL,<br>  <code>remark</code> varchar(255) DEFAULT NULL,<br>  PRIMARY KEY (<code>id</code>),<br>  KEY <code>idx_film_actor_id</code> (<code>film_id</code>,<code>actor_id</code>)<br>) ENGINE=InnoDB DEFAULT CHARSET=utf8;</p>
<h2 id="INSERT-INTO-film-actor-id-film-id-actor-id-VALUES-1-1-1-2-1-2-3-2-1"><a href="#INSERT-INTO-film-actor-id-film-id-actor-id-VALUES-1-1-1-2-1-2-3-2-1" class="headerlink" title="INSERT INTO film_actor (id, film_id, actor_id) VALUES (1,1,1),(2,1,2),(3,2,1);"></a>INSERT INTO <code>film_actor</code> (<code>id</code>, <code>film_id</code>, <code>actor_id</code>) VALUES (1,1,1),(2,1,2),(3,2,1);</h2><p>mysql&gt; explain select * from actor;</p>
<p>在查询中的每个表会输出一行，如果有两个表通过 join 连接查询，那么会输出两行。表的意义相当广泛：可以是子查询、一个 union 结果等。<br>explain 有两个变种：<br>1）explain extended：会在 explain  的基础上额外提供一些查询优化的信息。紧随其后通过 show warnings 命令可以 得到优化后的查询语句，从而看出优化器优化了什么。额外还有 filtered 列，是一个半分比的值，rows * filtered/100 可以估算出将要和 explain 中前一个表进行连接的行数（前一个表指 explain 中的id值比当前表id值小的表）。<br>mysql&gt; explain extended select * from film where id = 1;</p>
<p>mysql&gt; show warnings;</p>
<p>2）explain partitions：相比 explain 多了个 partitions 字段，如果查询是基于分区表的话，会显示查询将访问的分区。</p>
<p>explain 中的列<br>接下来我们将展示 explain 中每个列的信息。</p>
<ol>
<li>id列<br>id列的编号是 select 的序列号，有几个 select 就有几个id，并且id的顺序是按 select 出现的顺序增长的。MySQL将 select 查询分为简单查询(SIMPLE)和复杂查询(PRIMARY)。<br>复杂查询分为三类：简单子查询、派生表（from语句中的子查询）、union 查询。<br>id列越大执行优先级越高，id相同则从上往下执行，id为NULL最后执行<br>1）简单子查询<br>mysql&gt; explain select (select 1 from actor limit 1) from film;</li>
</ol>
<p>2）from子句中的子查询<br>mysql&gt; explain select id from (select id from film) as der;</p>
<p>这个查询执行时有个临时表别名为der，外部 select 查询引用了这个临时表</p>
<p>3）union查询<br>mysql&gt; explain select 1 union all select 1;</p>
<p>union结果总是放在一个匿名临时表中，临时表不在SQL中出现，因此它的id是NULL。</p>
<ol start="2">
<li>select_type列<br>select_type 表示对应行是简单还是复杂的查询，如果是复杂的查询，又是上述三种复杂查询中的哪一种。<br>1）simple：简单查询。查询不包含子查询和union<br>mysql&gt; explain select * from film where id = 2;</li>
</ol>
<p>2）primary：复杂查询中最外层的 select<br>3）subquery：包含在 select 中的子查询（不在 from 子句中）<br>4）derived：包含在 from 子句中的子查询。MySQL会将结果存放在一个临时表中，也称为派生表（derived的英文含义）<br>用这个例子来了解 primary、subquery 和 derived 类型<br>mysql&gt; explain select (select 1 from actor where id = 1) from (select * from film where id = 1) der;</p>
<p>5）union：在 union 中的第二个和随后的 select<br>6）union result：从 union 临时表检索结果的 select<br>用这个例子来了解 union 和 union result 类型：<br>mysql&gt; explain select 1 union all select 1;</p>
<ol start="3">
<li><p>table列<br>这一列表示 explain 的一行正在访问哪个表。<br>当 from 子句中有子查询时，table列是 <derivenN> 格式，表示当前查询依赖 id=N 的查询，于是先执行 id=N 的查询。<br>当有 union 时，UNION RESULT 的 table 列的值为&lt;union1,2&gt;，1和2表示参与 union 的 select 行id。</p>
</li>
<li><p>type列<br>这一列表示关联类型或访问类型，即MySQL决定如何查找表中的行，查找数据行记录的大概范围。<br>依次从最优到最差分别为：system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL<br>一般来说，得保证查询达到range级别，最好达到ref<br>NULL：mysql能够在优化阶段分解查询语句，在执行阶段用不着再访问表或索引。例如：在索引列中选取最小值，可以单独查找索引来完成，不需要在执行时访问表<br>mysql&gt; explain select min(id) from film;</p>
</li>
</ol>
<p>const, system：mysql能对查询的某部分进行优化并将其转化成一个常量（可以看show warnings 的结果）。用于 primary key 或 unique key 的所有列与常数比较时，所以表最多有一个匹配行，读取1次，速度比较快。system是const的特例，表里只有一条元组匹配时为system<br>mysql&gt; explain extended select * from (select * from film where id = 1) tmp;</p>
<p>mysql&gt; show warnings;</p>
<p>eq_ref：primary key 或 unique key 索引的所有部分被连接使用 ，最多只会返回一条符合条件的记录。这可能是在 const 之外最好的联接类型了，简单的 select 查询不会出现这种 type。<br>mysql&gt; explain select * from film_actor left join film on film_actor.film_id = film.id;</p>
<p>ref：相比 eq_ref，不使用唯一索引，而是使用普通索引或者唯一性索引的部分前缀，索引要和某个值相比较，可能会找到多个符合条件的行。</p>
<ol>
<li>简单 select 查询，name是普通索引（非唯一索引）<br>mysql&gt; explain select * from film where name = “film1”;</li>
</ol>
<p>2.关联表查询，idx_film_actor_id是film_id和actor_id的联合索引，这里使用到了film_actor的左边前缀film_id部分。<br>mysql&gt; explain select film_id from film left join film_actor on film.id = film_actor.film_id;</p>
<p>range：范围扫描通常出现在 in(), between ,&gt; ,&lt;, &gt;= 等操作中。使用一个索引来检索给定范围的行。<br>mysql&gt; explain select * from actor where id &gt; 1;</p>
<p>index：扫描全表索引，这通常比ALL快一些。（index是从索引中读取的，而all是从硬盘中读取）<br>mysql&gt; explain select * from film;</p>
<p>ALL：即全表扫描，意味着mysql需要从头到尾去查找所需要的行。通常情况下这需要增加索引来进行优化了<br>mysql&gt; explain select * from actor;</p>
<ol start="5">
<li><p>possible_keys列<br>这一列显示查询可能使用哪些索引来查找。<br>explain 时可能出现 possible_keys 有列，而 key 显示 NULL 的情况，这种情况是因为表中数据不多，mysql认为索引对此查询帮助不大，选择了全表查询。<br>如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查 where 子句看是否可以创造一个适当的索引来提高查询性能，然后用 explain 查看效果。</p>
</li>
<li><p>key列<br>这一列显示mysql实际采用哪个索引来优化对该表的访问。<br>如果没有使用索引，则该列是 NULL。如果想强制mysql使用或忽视possible_keys列中的索引，在查询中使用 force index、ignore index。</p>
</li>
<li><p>key_len列<br>这一列显示了mysql在索引里使用的字节数，通过这个值可以算出具体使用了索引中的哪些列。<br>举例来说，film_actor的联合索引 idx_film_actor_id 由 film_id 和 actor_id 两个int列组成，并且每个int是4字节。通过结果中的key_len=4可推断出查询使用了第一个列：film_id列来执行索引查找。<br>mysql&gt; explain select * from film_actor where film_id = 2;</p>
</li>
</ol>
<p>key_len计算规则如下：<br>字符串<br>char(n)：n字节长度<br>varchar(n)：2字节存储字符串长度，如果是utf-8，则长度 3n + 2<br>数值类型<br>tinyint：1字节<br>smallint：2字节<br>int：4字节<br>bigint：8字节　　<br>时间类型　<br>date：3字节<br>timestamp：4字节<br>datetime：8字节<br>如果字段允许为 NULL，需要1字节记录是否为 NULL<br>索引最大长度是768字节，当字符串过长时，mysql会做一个类似左前缀索引的处理，将前半部分的字符提取出来做索引。</p>
<ol start="8">
<li><p>ref列<br>这一列显示了在key列记录的索引中，表查找值所用到的列或常量，常见的有：const（常量），字段名（例：film.id）</p>
</li>
<li><p>rows列<br>这一列是mysql估计要读取并检测的行数，注意这个不是结果集里的行数。</p>
</li>
<li><p>Extra列<br>这一列展示的是额外信息。常见的重要值如下：<br>Using index：查询的列被索引覆盖，并且where筛选条件是索引的前导列，是性能高的表现。一般是使用了覆盖索引(索引包含了所有查询的字段)。对于innodb来说，如果是辅助索引性能会有不少提高<br>mysql&gt; explain select film_id from film_actor where film_id = 1;</p>
</li>
</ol>
<p>Using where：查询的列未被索引覆盖，where筛选条件非索引的前导列<br>mysql&gt; explain select * from actor where name = ‘a’;</p>
<p>Using where Using index：查询的列被索引覆盖，并且where筛选条件是索引列之一但是不是索引的前导列，意味着无法直接通过索引查找来查询到符合条件的数据<br>mysql&gt; explain select film_id from film_actor where actor_id = 1;</p>
<p>NULL：查询的列未被索引覆盖，并且where筛选条件是索引的前导列，意味着用到了索引，但是部分字段未被索引覆盖，必须通过“回表”来实现，不是纯粹地用到了索引，也不是完全没用到索引<br>mysql&gt;explain select * from film_actor where film_id = 1;</p>
<p>Using index condition：与Using where类似，查询的列不完全被索引覆盖，where条件中是一个前导列的范围；<br>mysql&gt; explain select * from film_actor where film_id &gt; 1;</p>
<p>Using temporary：mysql需要创建一张临时表来处理查询。出现这种情况一般是要进行优化的，首先是想到用索引来优化。</p>
<ol>
<li>actor.name没有索引，此时创建了张临时表来distinct<br>mysql&gt; explain select distinct name from actor;</li>
</ol>
<ol start="2">
<li>film.name建立了idx_name索引，此时查询时extra是using index,没有用临时表<br>mysql&gt; explain select distinct name from film;</li>
</ol>
<p>Using filesort：mysql 会对结果使用一个外部索引排序，而不是按索引次序从表里读取行。此时mysql会根据联接类型浏览所有符合条件的记录，并保存排序关键字和行指针，然后排序关键字并按顺序检索行信息。这种情况下一般也是要考虑使用索引来优化的。</p>
<ol>
<li>actor.name未创建索引，会浏览actor整个表，保存排序关键字name和对应的id，然后排序name并检索行记录<br>mysql&gt; explain select * from actor order by name;</li>
</ol>
<ol start="2">
<li>film.name建立了idx_name索引,此时查询时extra是using index<br>mysql&gt; explain select * from film order by name;</li>
</ol>
<p>索引最佳实践<br>使用的表<br>CREATE TABLE <code>employees</code> (<br>  <code>id</code> int(11) NOT NULL AUTO_INCREMENT,<br>  <code>name</code> varchar(24) NOT NULL DEFAULT ‘’ COMMENT ‘姓名’,<br>  <code>age</code> int(11) NOT NULL DEFAULT ‘0’ COMMENT ‘年龄’,<br>  <code>position</code> varchar(20) NOT NULL DEFAULT ‘’ COMMENT ‘职位’,<br>  <code>hire_time</code> timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT ‘入职时间’,<br>  PRIMARY KEY (<code>id</code>),<br>  KEY <code>idx_name_age_position</code> (<code>name</code>,<code>age</code>,<code>position</code>) USING BTREE<br>) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8 COMMENT=’员工记录表’;</p>
<p>INSERT INTO employees(name,age,position,hire_time) VALUES(‘LiLei’,22,’manager’,NOW());<br>INSERT INTO employees(name,age,position,hire_time) VALUES(‘HanMeimei’, 23,’dev’,NOW());<br>INSERT INTO employees(name,age,position,hire_time) VALUES(‘Lucy’,23,’dev’,NOW());</p>
<p>最佳实践</p>
<ol>
<li>全值匹配<br>EXPLAIN SELECT * FROM employees WHERE name= ‘LiLei’;</li>
</ol>
<p>EXPLAIN SELECT * FROM employees WHERE name= ‘LiLei’ AND age = 22;</p>
<p>EXPLAIN SELECT * FROM employees WHERE name= ‘LiLei’ AND age = 22 AND position =’manager’;</p>
<p>2.最佳左前缀法则<br> 如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始并且不跳过索引中的列。<br>EXPLAIN SELECT * FROM employees WHERE age = 22 AND position =’manager’;<br>EXPLAIN SELECT * FROM employees WHERE position = ‘manager’;<br>EXPLAIN SELECT * FROM employees WHERE name = ‘LiLei’;</p>
<p>3.不在索引列上做任何操作（计算、函数、（自动or手动）类型转换），会导致索引失效而转向全表扫描<br>EXPLAIN SELECT * FROM employees WHERE name = ‘LiLei’;<br>EXPLAIN SELECT * FROM employees WHERE left(name,3) = ‘LiLei’;</p>
<p>4.存储引擎不能使用索引中范围条件右边的列<br>EXPLAIN SELECT * FROM employees WHERE name= ‘LiLei’ AND age = 22 AND position =’manager’;<br>EXPLAIN SELECT * FROM employees WHERE name= ‘LiLei’ AND age &gt; 22 AND position =’manager’;</p>
<p>5.尽量使用覆盖索引（只访问索引的查询（索引列包含查询列）），减少select *语句<br>EXPLAIN SELECT name,age FROM employees WHERE name= ‘LiLei’ AND age = 23 AND position =’manager’;</p>
<p>EXPLAIN SELECT * FROM employees WHERE name= ‘LiLei’ AND age = 23 AND position =’manager’;</p>
<p>6.mysql在使用不等于（！=或者&lt;&gt;）的时候无法使用索引会导致全表扫描<br>EXPLAIN SELECT * FROM employees WHERE name != ‘LiLei’</p>
<p>7.is null,is not null 也无法使用索引<br>EXPLAIN SELECT * FROM employees WHERE name is null</p>
<p>8.like以通配符开头（’$abc…’）mysql索引失效会变成全表扫描操作<br>EXPLAIN SELECT * FROM employees WHERE name like ‘%Lei’</p>
<p>EXPLAIN SELECT * FROM employees WHERE name like ‘Lei%’</p>
<p>问题：解决like’%字符串%’索引不被使用的方法？<br>a）使用覆盖索引，查询字段必须是建立覆盖索引字段<br>EXPLAIN SELECT name,age,position FROM employees WHERE name like ‘%Lei%’;</p>
<p>b）当覆盖索引指向的字段是varchar(380)及380以上的字段时，覆盖索引会失效！</p>
<p>9.字符串不加单引号索引失效<br>EXPLAIN SELECT * FROM employees WHERE name = ‘1000’;<br>EXPLAIN SELECT * FROM employees WHERE name = 1000;</p>
<p>10.少用or或in，用它查询时，非主键字段的索引会失效，主键索引有时生效，有时不生效，跟数据量有关，具体还得看mysql的查询优化结果<br>EXPLAIN SELECT * FROM employees WHERE name = ‘LiLei’ or name = ‘HanMeimei’;</p>
<p>总结：</p>
<p>like KK%相当于=常量，%KK和%KK% 相当于范围</p>
<p>====================sql表述-explain=====================<br>– id列：select 的序列号，id的顺序是按 select 出现的顺序增长<br>– id列越大执行优先级越高，id相同则从上往下执行，id为NULL最后执行<br>– select_type列<br>explain select * from film where id = 2;<br>explain select (select 1 from actor where id = 1) from (select * from film where id = 1) der;</p>
<p>– type列：system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL<br>– const：用于 primary key 或 unique key 的所有列与常数比较时，所以表最多有一个匹配行<br>– system：system是const的特例，表里只有一条元组匹配时为system<br>explain extended select * from (select * from film where id = 1) tmp;<br>show warnings;<br>– eq_ref：primary key或unique key索引的所有部分被连接使用 ，最多只会返回一条符合条件的记录<br>explain select * from film_actor left join film on film_actor.film_id = film.id;<br>– ref：不使用唯一索引，而是使用普通索引或者唯一性索引的部分前缀，索引要和某个值相比较，可能会找到多个符合条件的行<br>explain select * from film where name = “film1”;<br>explain select film_id from film left join film_actor on film.id = film_actor.film_id;<br>– range：范围扫描通常出现在 in(), between ,&gt; ,&lt;, &gt;= 等操作中，使用一个索引来检索给定范围的行<br>explain select * from actor where id &gt; 1;<br>– index：全表索引扫描<br>explain select name from film;<br>– ALL：全表扫描(index是从索引中读取的，而all是从硬盘中读取)，通常情况下这需要增加索引来进行优化了<br>explain select name from actor;</p>
<p>– Extra列<br>– Using index：查询的列被索引覆盖，并且where筛选条件是索引的前导列，是性能高的表现<br>explain select film_id from film_actor where film_id = 1;<br>– Using where：查询的列未被索引覆盖，where筛选条件非索引的前导列<br>explain select * from film_actor where actor_id = 1;<br>– Using where;Using index：查询的列被索引覆盖，并且where筛选条件是索引列之一但是不是索引的前导列<br>– 意味着无法直接通过索引查找来查询到符合条件的数据<br>explain select film_id from film_actor where actor_id = 1;<br>– Using index condition：与Using where类似，查询的列不完全被索引覆盖，where条件中是一个前导列的范围；<br>explain select * from film_actor where film_id &gt; 1;<br>– Using temporary：mysql需要创建一张临时表来处理查询。<br>– 出现这种情况一般是要进行优化的，首先是想到用索引来优化。<br>explain select distinct name from actor;<br>explain select distinct name from film;<br>– Using filesort：mysql会对结果使用一个外部索引排序，而不是按索引次序从表里读取行<br>explain select * from actor order by name;<br>explain select * from film order by name;</p>
<p>====================sql表述-索引最佳实践=====================<br>– 1.联合索引全值匹配<br>EXPLAIN SELECT * FROM employees WHERE name= ‘LiLei’;<br>EXPLAIN SELECT * FROM employees WHERE name= ‘LiLei’ AND age = 22;<br>EXPLAIN SELECT * FROM employees WHERE name= ‘LiLei’ AND age = 22 AND position =’manager’;</p>
<p>– 2.最佳左前缀法则：查询从联合索引的最左前列开始并且不跳过索引中的列<br>EXPLAIN SELECT * FROM employees WHERE age = 22 AND position =’manager’;<br>EXPLAIN SELECT * FROM employees WHERE position = ‘manager’;<br>EXPLAIN SELECT * FROM employees WHERE name = ‘LiLei’;</p>
<p>– 3.不在索引列上做任何操作(计算、函数、(自动or手动)类型转换)，会导致索引失效而转向全表扫描<br>EXPLAIN SELECT * FROM employees WHERE name = ‘LiLei’;<br>EXPLAIN SELECT * FROM employees WHERE left(name,3) = ‘LiLei’;</p>
<p>– 4.存储引擎不能使用索引中范围条件右边的列<br>EXPLAIN SELECT * FROM employees WHERE name= ‘LiLei’ AND age = 22 AND position =’manager’;<br>EXPLAIN SELECT * FROM employees WHERE name= ‘LiLei’ AND age &gt; 22 AND position =’manager’;</p>
<p>– 5.尽量使用覆盖索引(只访问索引的查询(索引列包含查询列))，减少select *语句<br>EXPLAIN SELECT name,age,position FROM employees;<br>EXPLAIN SELECT * FROM employees;</p>
<p>– 6.mysql在使用不等于(!=或者&lt;&gt;)的时候无法使用索引会导致全表扫描<br>EXPLAIN SELECT * FROM employees WHERE name != ‘LiLei’;</p>
<p>– 7.is null,is not null 也无法使用索引<br>EXPLAIN SELECT * FROM employees WHERE name is null;</p>
<p>– 8.like以通配符开头(‘$abc…’)mysql索引失效会变成全表扫描操作<br>EXPLAIN SELECT * FROM employees WHERE name like ‘%Lei’;<br>EXPLAIN SELECT * FROM employees WHERE name like ‘Lei%’;</p>
<p>– 用覆盖索引优化like’%字符串%’<br>EXPLAIN SELECT name,age,position FROM employees WHERE name like ‘%Lei%’;</p>
<p>– 9.字符串不加单引号索引失效<br>EXPLAIN SELECT * FROM employees WHERE name = ‘1000’;<br>EXPLAIN SELECT * FROM employees WHERE name = 1000;</p>
<p>– 10.少用or或in，用它查询时，非主键字段的索引会失效，主键索引有时生效，有时不生效，跟数据量有关<br>– 具体还得看mysql的查询优化结果<br>EXPLAIN SELECT * FROM employees WHERE name = ‘LiLei’ or name = ‘HanMeimei’;</p>

            
            <p class="more">
                <a href="http://yoursite.com/2020/04/10/Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img="">
            <a href="http://yoursite.com/2020/04/10/Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/" title="Explain详解与索引最佳实践">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/0.jpg" alt="默认配图" >
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
            <a href="javascript: void(0);" class="cat">未分类</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="http://yoursite.com/2020/03/24/hello-world/">
    		Hello World
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2020-03-24T07:59:40.354Z">2020-03-24</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>

            
            <p class="more">
                <a href="http://yoursite.com/2020/03/24/hello-world/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img="">
            <a href="http://yoursite.com/2020/03/24/hello-world/" title="Hello World">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/4.jpg" alt="默认配图" >
                
            </a>
        </div>
    </div>
</article>

    

    
    <nav class="page-navigator">
        <span class="page-number current">1</span>
    </nav>
    




            </div>

        </section>
        <!-- 侧栏部分 -->
<aside class="sidebar">
    
    <section class="widget">
        <h3 class="widget-hd"><strong>文章搜索</strong></h3>
        <div class="search-form">
  <form
    id="searchForm"
    method="GET"
    action="https://www.baidu.com/s"
    ectype="application/x-www-form-urlencoded"
    target="_blank"
    autocomplete="false"
    onsubmit="javascript: return false;">
    <input
      id="searchKeyword"
      type="text"
      class="form-control"
      placeholder="输入关键字搜索"
      autocomplete="false"
    />
    <input id="searchKeywordHidden" type="hidden" name="wd" />
    <input id="searchButton" class="btn" type="submit" value="搜索" />
  </form>
</div>
    </section>
    

    <section class="widget">
        <h3 class="widget-hd"><strong>文章分类</strong></h3>
        <!-- 文章分类 -->
<ul class="widget-bd">
    
</ul>
    </section>

    
    <section class="widget">
        <h3 class="widget-hd"><strong>热门标签</strong></h3>
        <!-- 文章标签 -->
<div class="widget-bd tag-wrap">
  
</div>
    </section>
    

    

    
    <!-- 友情链接 -->
    <section class="widget">
        <h3 class="widget-hd"><strong>友情链接</strong></h3>
        <!-- 文章分类 -->
<ul class="widget-bd">
    
        <li>
            <a href="https://github.com/front-end-pigs/blog" target="_blank" title="Github博客">Github博客</a>
        </li>
    
</ul>
    </section>
    
</aside>
<!-- / 侧栏部分 -->
    </div>

    <!-- 博客底部 -->
    <footer class="footer">
    &copy;
    
        2016-2020
    

    <a href="/">Jelon Loves You</a>
</footer>
<div class="back-to-top" id="JELON__backToTop" title="返回顶部">返回顶部</div>

    <!--博客js脚本 -->
    <!-- 这里放网站js脚本 -->

<script src="/js/main.js?v=1586938917119.js"></script>

</body>
</html>