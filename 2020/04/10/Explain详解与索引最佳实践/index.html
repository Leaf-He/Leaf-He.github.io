<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Explain详解与索引最佳实践 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="使用EXPLAIN关键字可以模拟优化器执行SQL语句，从而知道MySQL是 如何处理你的SQL语句的。分析你的查询语句或是结构的性能瓶颈下面是使用 explain 的例子：在 select 语句之前增加 explain 关键字，MySQL 会在查询上设置一个标记，执行查询时，会返回执行计划的信息，而不是执行这条SQL（如果 from 中包含子查询，仍会执行该子查询，将结果放入临时表中）使用的表DR">
<meta property="og:type" content="article">
<meta property="og:title" content="Explain详解与索引最佳实践">
<meta property="og:url" content="http://yoursite.com/2020/04/10/Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="使用EXPLAIN关键字可以模拟优化器执行SQL语句，从而知道MySQL是 如何处理你的SQL语句的。分析你的查询语句或是结构的性能瓶颈下面是使用 explain 的例子：在 select 语句之前增加 explain 关键字，MySQL 会在查询上设置一个标记，执行查询时，会返回执行计划的信息，而不是执行这条SQL（如果 from 中包含子查询，仍会执行该子查询，将结果放入临时表中）使用的表DR">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-04-10T06:05:11.688Z">
<meta property="article:modified_time" content="2020-04-10T06:13:19.768Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Explain详解与索引最佳实践" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/10/Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/" class="article-date">
  <time datetime="2020-04-10T06:05:11.688Z" itemprop="datePublished">2020-04-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Explain详解与索引最佳实践
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>使用EXPLAIN关键字可以模拟优化器执行SQL语句，从而知道MySQL是 如何处理你的SQL语句的。分析你的查询语句或是结构的性能瓶颈<br>下面是使用 explain 的例子：<br>在 select 语句之前增加 explain 关键字，MySQL 会在查询上设置一个标记，执行查询时，会返回执行计划的信息，而不是执行这条SQL（如果 from 中包含子查询，仍会执行该子查询，将结果放入临时表中）<br>使用的表<br>DROP TABLE IF EXISTS <code>actor</code>;<br>CREATE TABLE <code>actor</code> (<br>  <code>id</code> int(11) NOT NULL,<br>  <code>name</code> varchar(45) DEFAULT NULL,<br>  <code>update_time</code> datetime DEFAULT NULL,<br>  PRIMARY KEY (<code>id</code>)<br>) ENGINE=InnoDB DEFAULT CHARSET=utf8;</p>
<p>INSERT INTO <code>actor</code> (<code>id</code>, <code>name</code>, <code>update_time</code>) VALUES (1,’a’,’2017-12-22 15:27:18’), (2,’b’,’2017-12-22 15:27:18’), (3,’c’,’2017-12-22 15:27:18’);</p>
<p>DROP TABLE IF EXISTS <code>film</code>;<br>CREATE TABLE <code>film</code> (<br>  <code>id</code> int(11) NOT NULL AUTO_INCREMENT,<br>  <code>name</code> varchar(10) DEFAULT NULL,<br>  PRIMARY KEY (<code>id</code>),<br>  KEY <code>idx_name</code> (<code>name</code>)<br>) ENGINE=InnoDB DEFAULT CHARSET=utf8;</p>
<p>INSERT INTO <code>film</code> (<code>id</code>, <code>name</code>) VALUES (3,’film0’),(1,’film1’),(2,’film2’);</p>
<p>DROP TABLE IF EXISTS <code>film_actor</code>;<br>CREATE TABLE <code>film_actor</code> (<br>  <code>id</code> int(11) NOT NULL,<br>  <code>film_id</code> int(11) NOT NULL,<br>  <code>actor_id</code> int(11) NOT NULL,<br>  <code>remark</code> varchar(255) DEFAULT NULL,<br>  PRIMARY KEY (<code>id</code>),<br>  KEY <code>idx_film_actor_id</code> (<code>film_id</code>,<code>actor_id</code>)<br>) ENGINE=InnoDB DEFAULT CHARSET=utf8;</p>
<h2 id="INSERT-INTO-film-actor-id-film-id-actor-id-VALUES-1-1-1-2-1-2-3-2-1"><a href="#INSERT-INTO-film-actor-id-film-id-actor-id-VALUES-1-1-1-2-1-2-3-2-1" class="headerlink" title="INSERT INTO film_actor (id, film_id, actor_id) VALUES (1,1,1),(2,1,2),(3,2,1);"></a>INSERT INTO <code>film_actor</code> (<code>id</code>, <code>film_id</code>, <code>actor_id</code>) VALUES (1,1,1),(2,1,2),(3,2,1);</h2><p>mysql&gt; explain select * from actor;</p>
<p>在查询中的每个表会输出一行，如果有两个表通过 join 连接查询，那么会输出两行。表的意义相当广泛：可以是子查询、一个 union 结果等。<br>explain 有两个变种：<br>1）explain extended：会在 explain  的基础上额外提供一些查询优化的信息。紧随其后通过 show warnings 命令可以 得到优化后的查询语句，从而看出优化器优化了什么。额外还有 filtered 列，是一个半分比的值，rows * filtered/100 可以估算出将要和 explain 中前一个表进行连接的行数（前一个表指 explain 中的id值比当前表id值小的表）。<br>mysql&gt; explain extended select * from film where id = 1;</p>
<p>mysql&gt; show warnings;</p>
<p>2）explain partitions：相比 explain 多了个 partitions 字段，如果查询是基于分区表的话，会显示查询将访问的分区。</p>
<p>explain 中的列<br>接下来我们将展示 explain 中每个列的信息。</p>
<ol>
<li>id列<br>id列的编号是 select 的序列号，有几个 select 就有几个id，并且id的顺序是按 select 出现的顺序增长的。MySQL将 select 查询分为简单查询(SIMPLE)和复杂查询(PRIMARY)。<br>复杂查询分为三类：简单子查询、派生表（from语句中的子查询）、union 查询。<br>id列越大执行优先级越高，id相同则从上往下执行，id为NULL最后执行<br>1）简单子查询<br>mysql&gt; explain select (select 1 from actor limit 1) from film;</li>
</ol>
<p>2）from子句中的子查询<br>mysql&gt; explain select id from (select id from film) as der;</p>
<p>这个查询执行时有个临时表别名为der，外部 select 查询引用了这个临时表</p>
<p>3）union查询<br>mysql&gt; explain select 1 union all select 1;</p>
<p>union结果总是放在一个匿名临时表中，临时表不在SQL中出现，因此它的id是NULL。</p>
<ol start="2">
<li>select_type列<br>select_type 表示对应行是简单还是复杂的查询，如果是复杂的查询，又是上述三种复杂查询中的哪一种。<br>1）simple：简单查询。查询不包含子查询和union<br>mysql&gt; explain select * from film where id = 2;</li>
</ol>
<p>2）primary：复杂查询中最外层的 select<br>3）subquery：包含在 select 中的子查询（不在 from 子句中）<br>4）derived：包含在 from 子句中的子查询。MySQL会将结果存放在一个临时表中，也称为派生表（derived的英文含义）<br>用这个例子来了解 primary、subquery 和 derived 类型<br>mysql&gt; explain select (select 1 from actor where id = 1) from (select * from film where id = 1) der;</p>
<p>5）union：在 union 中的第二个和随后的 select<br>6）union result：从 union 临时表检索结果的 select<br>用这个例子来了解 union 和 union result 类型：<br>mysql&gt; explain select 1 union all select 1;</p>
<ol start="3">
<li><p>table列<br>这一列表示 explain 的一行正在访问哪个表。<br>当 from 子句中有子查询时，table列是 <derivenN> 格式，表示当前查询依赖 id=N 的查询，于是先执行 id=N 的查询。<br>当有 union 时，UNION RESULT 的 table 列的值为&lt;union1,2&gt;，1和2表示参与 union 的 select 行id。</p>
</li>
<li><p>type列<br>这一列表示关联类型或访问类型，即MySQL决定如何查找表中的行，查找数据行记录的大概范围。<br>依次从最优到最差分别为：system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL<br>一般来说，得保证查询达到range级别，最好达到ref<br>NULL：mysql能够在优化阶段分解查询语句，在执行阶段用不着再访问表或索引。例如：在索引列中选取最小值，可以单独查找索引来完成，不需要在执行时访问表<br>mysql&gt; explain select min(id) from film;</p>
</li>
</ol>
<p>const, system：mysql能对查询的某部分进行优化并将其转化成一个常量（可以看show warnings 的结果）。用于 primary key 或 unique key 的所有列与常数比较时，所以表最多有一个匹配行，读取1次，速度比较快。system是const的特例，表里只有一条元组匹配时为system<br>mysql&gt; explain extended select * from (select * from film where id = 1) tmp;</p>
<p>mysql&gt; show warnings;</p>
<p>eq_ref：primary key 或 unique key 索引的所有部分被连接使用 ，最多只会返回一条符合条件的记录。这可能是在 const 之外最好的联接类型了，简单的 select 查询不会出现这种 type。<br>mysql&gt; explain select * from film_actor left join film on film_actor.film_id = film.id;</p>
<p>ref：相比 eq_ref，不使用唯一索引，而是使用普通索引或者唯一性索引的部分前缀，索引要和某个值相比较，可能会找到多个符合条件的行。</p>
<ol>
<li>简单 select 查询，name是普通索引（非唯一索引）<br>mysql&gt; explain select * from film where name = “film1”;</li>
</ol>
<p>2.关联表查询，idx_film_actor_id是film_id和actor_id的联合索引，这里使用到了film_actor的左边前缀film_id部分。<br>mysql&gt; explain select film_id from film left join film_actor on film.id = film_actor.film_id;</p>
<p>range：范围扫描通常出现在 in(), between ,&gt; ,&lt;, &gt;= 等操作中。使用一个索引来检索给定范围的行。<br>mysql&gt; explain select * from actor where id &gt; 1;</p>
<p>index：扫描全表索引，这通常比ALL快一些。（index是从索引中读取的，而all是从硬盘中读取）<br>mysql&gt; explain select * from film;</p>
<p>ALL：即全表扫描，意味着mysql需要从头到尾去查找所需要的行。通常情况下这需要增加索引来进行优化了<br>mysql&gt; explain select * from actor;</p>
<ol start="5">
<li><p>possible_keys列<br>这一列显示查询可能使用哪些索引来查找。<br>explain 时可能出现 possible_keys 有列，而 key 显示 NULL 的情况，这种情况是因为表中数据不多，mysql认为索引对此查询帮助不大，选择了全表查询。<br>如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查 where 子句看是否可以创造一个适当的索引来提高查询性能，然后用 explain 查看效果。</p>
</li>
<li><p>key列<br>这一列显示mysql实际采用哪个索引来优化对该表的访问。<br>如果没有使用索引，则该列是 NULL。如果想强制mysql使用或忽视possible_keys列中的索引，在查询中使用 force index、ignore index。</p>
</li>
<li><p>key_len列<br>这一列显示了mysql在索引里使用的字节数，通过这个值可以算出具体使用了索引中的哪些列。<br>举例来说，film_actor的联合索引 idx_film_actor_id 由 film_id 和 actor_id 两个int列组成，并且每个int是4字节。通过结果中的key_len=4可推断出查询使用了第一个列：film_id列来执行索引查找。<br>mysql&gt; explain select * from film_actor where film_id = 2;</p>
</li>
</ol>
<p>key_len计算规则如下：<br>字符串<br>char(n)：n字节长度<br>varchar(n)：2字节存储字符串长度，如果是utf-8，则长度 3n + 2<br>数值类型<br>tinyint：1字节<br>smallint：2字节<br>int：4字节<br>bigint：8字节　　<br>时间类型　<br>date：3字节<br>timestamp：4字节<br>datetime：8字节<br>如果字段允许为 NULL，需要1字节记录是否为 NULL<br>索引最大长度是768字节，当字符串过长时，mysql会做一个类似左前缀索引的处理，将前半部分的字符提取出来做索引。</p>
<ol start="8">
<li><p>ref列<br>这一列显示了在key列记录的索引中，表查找值所用到的列或常量，常见的有：const（常量），字段名（例：film.id）</p>
</li>
<li><p>rows列<br>这一列是mysql估计要读取并检测的行数，注意这个不是结果集里的行数。</p>
</li>
<li><p>Extra列<br>这一列展示的是额外信息。常见的重要值如下：<br>Using index：查询的列被索引覆盖，并且where筛选条件是索引的前导列，是性能高的表现。一般是使用了覆盖索引(索引包含了所有查询的字段)。对于innodb来说，如果是辅助索引性能会有不少提高<br>mysql&gt; explain select film_id from film_actor where film_id = 1;</p>
</li>
</ol>
<p>Using where：查询的列未被索引覆盖，where筛选条件非索引的前导列<br>mysql&gt; explain select * from actor where name = ‘a’;</p>
<p>Using where Using index：查询的列被索引覆盖，并且where筛选条件是索引列之一但是不是索引的前导列，意味着无法直接通过索引查找来查询到符合条件的数据<br>mysql&gt; explain select film_id from film_actor where actor_id = 1;</p>
<p>NULL：查询的列未被索引覆盖，并且where筛选条件是索引的前导列，意味着用到了索引，但是部分字段未被索引覆盖，必须通过“回表”来实现，不是纯粹地用到了索引，也不是完全没用到索引<br>mysql&gt;explain select * from film_actor where film_id = 1;</p>
<p>Using index condition：与Using where类似，查询的列不完全被索引覆盖，where条件中是一个前导列的范围；<br>mysql&gt; explain select * from film_actor where film_id &gt; 1;</p>
<p>Using temporary：mysql需要创建一张临时表来处理查询。出现这种情况一般是要进行优化的，首先是想到用索引来优化。</p>
<ol>
<li>actor.name没有索引，此时创建了张临时表来distinct<br>mysql&gt; explain select distinct name from actor;</li>
</ol>
<ol start="2">
<li>film.name建立了idx_name索引，此时查询时extra是using index,没有用临时表<br>mysql&gt; explain select distinct name from film;</li>
</ol>
<p>Using filesort：mysql 会对结果使用一个外部索引排序，而不是按索引次序从表里读取行。此时mysql会根据联接类型浏览所有符合条件的记录，并保存排序关键字和行指针，然后排序关键字并按顺序检索行信息。这种情况下一般也是要考虑使用索引来优化的。</p>
<ol>
<li>actor.name未创建索引，会浏览actor整个表，保存排序关键字name和对应的id，然后排序name并检索行记录<br>mysql&gt; explain select * from actor order by name;</li>
</ol>
<ol start="2">
<li>film.name建立了idx_name索引,此时查询时extra是using index<br>mysql&gt; explain select * from film order by name;</li>
</ol>
<p>索引最佳实践<br>使用的表<br>CREATE TABLE <code>employees</code> (<br>  <code>id</code> int(11) NOT NULL AUTO_INCREMENT,<br>  <code>name</code> varchar(24) NOT NULL DEFAULT ‘’ COMMENT ‘姓名’,<br>  <code>age</code> int(11) NOT NULL DEFAULT ‘0’ COMMENT ‘年龄’,<br>  <code>position</code> varchar(20) NOT NULL DEFAULT ‘’ COMMENT ‘职位’,<br>  <code>hire_time</code> timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT ‘入职时间’,<br>  PRIMARY KEY (<code>id</code>),<br>  KEY <code>idx_name_age_position</code> (<code>name</code>,<code>age</code>,<code>position</code>) USING BTREE<br>) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8 COMMENT=’员工记录表’;</p>
<p>INSERT INTO employees(name,age,position,hire_time) VALUES(‘LiLei’,22,’manager’,NOW());<br>INSERT INTO employees(name,age,position,hire_time) VALUES(‘HanMeimei’, 23,’dev’,NOW());<br>INSERT INTO employees(name,age,position,hire_time) VALUES(‘Lucy’,23,’dev’,NOW());</p>
<p>最佳实践</p>
<ol>
<li>全值匹配<br>EXPLAIN SELECT * FROM employees WHERE name= ‘LiLei’;</li>
</ol>
<p>EXPLAIN SELECT * FROM employees WHERE name= ‘LiLei’ AND age = 22;</p>
<p>EXPLAIN SELECT * FROM employees WHERE name= ‘LiLei’ AND age = 22 AND position =’manager’;</p>
<p>2.最佳左前缀法则<br> 如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始并且不跳过索引中的列。<br>EXPLAIN SELECT * FROM employees WHERE age = 22 AND position =’manager’;<br>EXPLAIN SELECT * FROM employees WHERE position = ‘manager’;<br>EXPLAIN SELECT * FROM employees WHERE name = ‘LiLei’;</p>
<p>3.不在索引列上做任何操作（计算、函数、（自动or手动）类型转换），会导致索引失效而转向全表扫描<br>EXPLAIN SELECT * FROM employees WHERE name = ‘LiLei’;<br>EXPLAIN SELECT * FROM employees WHERE left(name,3) = ‘LiLei’;</p>
<p>4.存储引擎不能使用索引中范围条件右边的列<br>EXPLAIN SELECT * FROM employees WHERE name= ‘LiLei’ AND age = 22 AND position =’manager’;<br>EXPLAIN SELECT * FROM employees WHERE name= ‘LiLei’ AND age &gt; 22 AND position =’manager’;</p>
<p>5.尽量使用覆盖索引（只访问索引的查询（索引列包含查询列）），减少select *语句<br>EXPLAIN SELECT name,age FROM employees WHERE name= ‘LiLei’ AND age = 23 AND position =’manager’;</p>
<p>EXPLAIN SELECT * FROM employees WHERE name= ‘LiLei’ AND age = 23 AND position =’manager’;</p>
<p>6.mysql在使用不等于（！=或者&lt;&gt;）的时候无法使用索引会导致全表扫描<br>EXPLAIN SELECT * FROM employees WHERE name != ‘LiLei’</p>
<p>7.is null,is not null 也无法使用索引<br>EXPLAIN SELECT * FROM employees WHERE name is null</p>
<p>8.like以通配符开头（’$abc…’）mysql索引失效会变成全表扫描操作<br>EXPLAIN SELECT * FROM employees WHERE name like ‘%Lei’</p>
<p>EXPLAIN SELECT * FROM employees WHERE name like ‘Lei%’</p>
<p>问题：解决like’%字符串%’索引不被使用的方法？<br>a）使用覆盖索引，查询字段必须是建立覆盖索引字段<br>EXPLAIN SELECT name,age,position FROM employees WHERE name like ‘%Lei%’;</p>
<p>b）当覆盖索引指向的字段是varchar(380)及380以上的字段时，覆盖索引会失效！</p>
<p>9.字符串不加单引号索引失效<br>EXPLAIN SELECT * FROM employees WHERE name = ‘1000’;<br>EXPLAIN SELECT * FROM employees WHERE name = 1000;</p>
<p>10.少用or或in，用它查询时，非主键字段的索引会失效，主键索引有时生效，有时不生效，跟数据量有关，具体还得看mysql的查询优化结果<br>EXPLAIN SELECT * FROM employees WHERE name = ‘LiLei’ or name = ‘HanMeimei’;</p>
<p>总结：</p>
<p>like KK%相当于=常量，%KK和%KK% 相当于范围</p>
<p>====================sql表述-explain=====================<br>– id列：select 的序列号，id的顺序是按 select 出现的顺序增长<br>– id列越大执行优先级越高，id相同则从上往下执行，id为NULL最后执行<br>– select_type列<br>explain select * from film where id = 2;<br>explain select (select 1 from actor where id = 1) from (select * from film where id = 1) der;</p>
<p>– type列：system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL<br>– const：用于 primary key 或 unique key 的所有列与常数比较时，所以表最多有一个匹配行<br>– system：system是const的特例，表里只有一条元组匹配时为system<br>explain extended select * from (select * from film where id = 1) tmp;<br>show warnings;<br>– eq_ref：primary key或unique key索引的所有部分被连接使用 ，最多只会返回一条符合条件的记录<br>explain select * from film_actor left join film on film_actor.film_id = film.id;<br>– ref：不使用唯一索引，而是使用普通索引或者唯一性索引的部分前缀，索引要和某个值相比较，可能会找到多个符合条件的行<br>explain select * from film where name = “film1”;<br>explain select film_id from film left join film_actor on film.id = film_actor.film_id;<br>– range：范围扫描通常出现在 in(), between ,&gt; ,&lt;, &gt;= 等操作中，使用一个索引来检索给定范围的行<br>explain select * from actor where id &gt; 1;<br>– index：全表索引扫描<br>explain select name from film;<br>– ALL：全表扫描(index是从索引中读取的，而all是从硬盘中读取)，通常情况下这需要增加索引来进行优化了<br>explain select name from actor;</p>
<p>– Extra列<br>– Using index：查询的列被索引覆盖，并且where筛选条件是索引的前导列，是性能高的表现<br>explain select film_id from film_actor where film_id = 1;<br>– Using where：查询的列未被索引覆盖，where筛选条件非索引的前导列<br>explain select * from film_actor where actor_id = 1;<br>– Using where;Using index：查询的列被索引覆盖，并且where筛选条件是索引列之一但是不是索引的前导列<br>– 意味着无法直接通过索引查找来查询到符合条件的数据<br>explain select film_id from film_actor where actor_id = 1;<br>– Using index condition：与Using where类似，查询的列不完全被索引覆盖，where条件中是一个前导列的范围；<br>explain select * from film_actor where film_id &gt; 1;<br>– Using temporary：mysql需要创建一张临时表来处理查询。<br>– 出现这种情况一般是要进行优化的，首先是想到用索引来优化。<br>explain select distinct name from actor;<br>explain select distinct name from film;<br>– Using filesort：mysql会对结果使用一个外部索引排序，而不是按索引次序从表里读取行<br>explain select * from actor order by name;<br>explain select * from film order by name;</p>
<p>====================sql表述-索引最佳实践=====================<br>– 1.联合索引全值匹配<br>EXPLAIN SELECT * FROM employees WHERE name= ‘LiLei’;<br>EXPLAIN SELECT * FROM employees WHERE name= ‘LiLei’ AND age = 22;<br>EXPLAIN SELECT * FROM employees WHERE name= ‘LiLei’ AND age = 22 AND position =’manager’;</p>
<p>– 2.最佳左前缀法则：查询从联合索引的最左前列开始并且不跳过索引中的列<br>EXPLAIN SELECT * FROM employees WHERE age = 22 AND position =’manager’;<br>EXPLAIN SELECT * FROM employees WHERE position = ‘manager’;<br>EXPLAIN SELECT * FROM employees WHERE name = ‘LiLei’;</p>
<p>– 3.不在索引列上做任何操作(计算、函数、(自动or手动)类型转换)，会导致索引失效而转向全表扫描<br>EXPLAIN SELECT * FROM employees WHERE name = ‘LiLei’;<br>EXPLAIN SELECT * FROM employees WHERE left(name,3) = ‘LiLei’;</p>
<p>– 4.存储引擎不能使用索引中范围条件右边的列<br>EXPLAIN SELECT * FROM employees WHERE name= ‘LiLei’ AND age = 22 AND position =’manager’;<br>EXPLAIN SELECT * FROM employees WHERE name= ‘LiLei’ AND age &gt; 22 AND position =’manager’;</p>
<p>– 5.尽量使用覆盖索引(只访问索引的查询(索引列包含查询列))，减少select *语句<br>EXPLAIN SELECT name,age,position FROM employees;<br>EXPLAIN SELECT * FROM employees;</p>
<p>– 6.mysql在使用不等于(!=或者&lt;&gt;)的时候无法使用索引会导致全表扫描<br>EXPLAIN SELECT * FROM employees WHERE name != ‘LiLei’;</p>
<p>– 7.is null,is not null 也无法使用索引<br>EXPLAIN SELECT * FROM employees WHERE name is null;</p>
<p>– 8.like以通配符开头(‘$abc…’)mysql索引失效会变成全表扫描操作<br>EXPLAIN SELECT * FROM employees WHERE name like ‘%Lei’;<br>EXPLAIN SELECT * FROM employees WHERE name like ‘Lei%’;</p>
<p>– 用覆盖索引优化like’%字符串%’<br>EXPLAIN SELECT name,age,position FROM employees WHERE name like ‘%Lei%’;</p>
<p>– 9.字符串不加单引号索引失效<br>EXPLAIN SELECT * FROM employees WHERE name = ‘1000’;<br>EXPLAIN SELECT * FROM employees WHERE name = 1000;</p>
<p>– 10.少用or或in，用它查询时，非主键字段的索引会失效，主键索引有时生效，有时不生效，跟数据量有关<br>– 具体还得看mysql的查询优化结果<br>EXPLAIN SELECT * FROM employees WHERE name = ‘LiLei’ or name = ‘HanMeimei’;</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/10/Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/" data-id="ck8tt487j00008wtb5db31j07" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2020/03/24/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/04/10/Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/">Explain详解与索引最佳实践</a>
          </li>
        
          <li>
            <a href="/2020/03/24/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>